# TDMA-RISC

TDMA-RISC provides three services:
* A command queue and command processor for instructing the mover.
* Some packer configuration fields used by `PACR_SETREG` and unpacker configuration fields used by `UNPACR_NOP`.
* Access to some sideband metadata generated by packers and unpackers.

## Memory map

See the functional specification (below) for state and functions referenced herein.

Addresses primarily related to the command queue and command processor for instructing the mover:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_XMOV_SRC_ADDR`<br/>`0xFFB1_1000`|`CmdParams[0] = new_val`|`return 0`|
|`RISCV_TDMA_REG_XMOV_DST_ADDR`<br/>`0xFFB1_1004`|`CmdParams[1] = new_val`|`return 0`|
|`RISCV_TDMA_REG_XMOV_SIZE`<br/>`0xFFB1_1008`|`CmdParams[2] = new_val`|`return 0`|
|`RISCV_TDMA_REG_XMOV_DIRECTION`<br/>`0xFFB1_100C`|`CmdParams[3] = new_val`|`return 0`|
|`RISCV_TDMA_REG_COMMAND_ADDR`<br/>`0xFFB1_1010`|`EnqueueCmd(new_val)`|`return 0`|
|`RISCV_TDMA_REG_STATUS`<br/>`0xFFB1_1014`|No effect|`return StatusBits()`|
|`RISCV_TDMA_REG_XMOV_L1_BASE_ADDR`<br/>`0xFFB1_102C`|`MovCmdBase[CurrentThread] = new_val`|`return CurrentThreadMovCmdBase()`|

Addresses primarily related to `PACR_SETREG` and `UNPACR_NOP` configuration:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_CLK_GATE_EN`<br/>`0xFFB1_1024`|`UnpackRegAddrRaw = new_val & 0xffffff7f`<br/>`SetUnpackRegAddr(new_val)`|`return UnpackRegAddrRaw`|
|`RISCV_TDMA_REG_CLK_GATE_HYST`<br/>`0xFFB1_1028`|`Scaler2Raw = new_val & 0x01ff007f`<br/>`SetScaler(3, new_val)`|`return Scaler2Raw`|
|`0xFFB1_103C`|`SetScaler(0, new_val)`|`return ScalarsAndStatus(0)`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_STATUS`<br/>`0xFFB1_1038`|`SetPackRegAddr(new_val)`|`return MetadataFIFOStatus()`|
|`0xFFB1_113C`|`SetScaler(0, new_val)`|`return ScalarsAndStatus(1)`|

Addresses primarily related to sideband metadata generated by packer 0 or unpacker 0:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_PACKED_SIZE`<br/>`0xFFB1_1018`|No effect|`return PackerTileSize(0, 0)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE`<br/>`0xFFB1_101C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(0, 0)`|
|`0xFFB1_1020`|No effect|`return Packers[0].AllZeroFlags`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_SIZE(0)`<br/>`0xFFB1_1030`|No effect|`return Packers[0].MetadataFIFO.Peek().TileSize`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_ZEROMASK(0)`<br/>`0xFFB1_1034`|`Packers[0].MetadataFIFO.Pop()`|`return Packers[0].MetadataFIFO.Pop().AllZeroFlags`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x040`<br/>`0xFFB1_1058`|No effect|`return PackerTileSize(0, 1)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x040`<br/>`0xFFB1_105C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(0, 1)`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x080`<br/>`0xFFB1_1098`|No effect|`return PackerTileSize(0, 2)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x080`<br/>`0xFFB1_109C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(0, 2)`|

Addresses primarily related to sideband metadata generated by packer 1 or unpacker 1:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x100`<br/>`0xFFB1_1118`|No effect|`return PackerTileSize(1, 0)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x100`<br/>`0xFFB1_111C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(1, 0)`|
|`0xFFB1_1120`|No effect|`return Packers[1].AllZeroFlags`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_SIZE(1)`<br/>`0xFFB1_1130`|No effect|`return Packers[1].MetadataFIFO.Peek().TileSize`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_ZEROMASK(1)`<br/>`0xFFB1_1134`|`Packers[1].MetadataFIFO.Pop()`|`return Packers[1].MetadataFIFO.Pop().AllZeroFlags`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x140`<br/>`0xFFB1_1158`|No effect|`return PackerTileSize(1, 1)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x140`<br/>`0xFFB1_115C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(1, 1)`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x180`<br/>`0xFFB1_1198`|No effect|`return PackerTileSize(1, 2)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x180`<br/>`0xFFB1_119C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(1, 2)`|

Addresses primarily related to sideband metadata generated by packer 2:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x200`<br/>`0xFFB1_1218`|No effect|`return PackerTileSize(2, 0)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x200`<br/>`0xFFB1_121C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(2, 0)`|
|`0xFFB1_1220`|No effect|`return Packers[2].AllZeroFlags`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_SIZE(2)`<br/>`0xFFB1_1230`|No effect|`return Packers[2].MetadataFIFO.Peek().TileSize`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_ZEROMASK(2)`<br/>`0xFFB1_1234`|`Packers[2].MetadataFIFO.Pop()`|`return Packers[2].MetadataFIFO.Pop().AllZeroFlags`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x240`<br/>`0xFFB1_1258`|No effect|`return PackerTileSize(2, 1)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x240`<br/>`0xFFB1_125C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(2, 1)`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x280`<br/>`0xFFB1_1298`|No effect|`return PackerTileSize(2, 2)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x280`<br/>`0xFFB1_129C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(2, 2)`|

Addresses primarily related to sideband metadata generated by packer 3:

|Address|Write Behaviour|Read Behaviour|
|---|---|---|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x300`<br/>`0xFFB1_1318`|No effect|`return PackerTileSize(3, 0)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x300`<br/>`0xFFB1_131C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(3, 0)`|
|`0xFFB1_1320`|No effect|`return Packers[3].AllZeroFlags`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_SIZE(3)`<br/>`0xFFB1_1330`|No effect|`return Packers[3].MetadataFIFO.Peek().TileSize`|
|`RISCV_TDMA_REG_FIFO_PACKED_TILE_ZEROMASK(3)`<br/>`0xFFB1_1334`|`Packers[3].MetadataFIFO.Pop()`|`return Packers[3].MetadataFIFO.Pop().AllZeroFlags`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x340`<br/>`0xFFB1_1358`|No effect|`return PackerTileSize(3, 1)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x340`<br/>`0xFFB1_135C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(3, 1)`|
|`RISCV_TDMA_REG_PACKED_SIZE + 0x380`<br/>`0xFFB1_1398`|No effect|`return PackerTileSize(3, 2)`|
|`RISCV_TDMA_REG_ACC_PACKED_SIZE + 0x380`<br/>`0xFFB1_139C`|`ResetPackerAccTileSize(new_val)`|`return UnpackerPackerAcc(3, 2)`|

## Functional specification

Primarily related to the command queue and command processor for instructing the mover:

```c
uint32_t CmdParams[4];
uint32_t MovCmdBase[4];
unsigned ParameterCredits = 2;

void EnqueueCmd(uint32_t Cmd) {
  while (CommandQueue.IsFull()) {
    wait;
  }
  if (Cmd >> 31) {
    // Compact command consisting of just the written 32 bits
    CommandQueue.Push({Cmd, {0, 0, 0, 0}});
  } else {
    // Command with parameters; the written 32 bits, plus 4x32 bits from CmdParams
    if (ParameterCredits == 0) {
      // EnqueueCmd is meant to wait when ParameterCredits == 0, but due to a
      // hardware bug, it does not. Software needs to avoid hitting this path.
      // One way of achieving this is by enqueueing a NOP command (0x80000089) after
      // enqueueing any command with parameters, as this should ensure that the
      // CommandQueue capacity is hit before ParameterCredits == 0 is hit.
      UndefinedBehaviour();
    }
    ParameterCredits -= 1;
    CommandQueue.Push({Cmd, {CmdParams[0], CmdParams[1], CmdParams[2], CmdParams[3]}});
  }
}

struct StatusBitsResult {
  bool mover_busy : 1;
  bool reserved : 1;
  bool command_queue_full;
  bool command_queue_empty;
  bool parameter_queue_full;
  bool parameter_queue_empty;
  unsigned reserved : 2;
  uint8_t command_queue_remaining_capacity;
  bool packer_reg_write_fifo_full : 1;
  bool unpacker_reg_write_fifo_full : 1;
  unsigned reserved : 10;
}

StatusBitsResult StatusBits() {
  StatusBitsResult result;
  result.mover_busy = Mover.IsBusy(); // Same control signal as STALLWAIT would use for condition C12
  result.command_queue_full = CommandQueue.IsFull();
  result.command_queue_empty = CommandQueue.IsEmpty();
  result.parameter_queue_full = (ParameterCredits == 0);
  result.parameter_queue_empty = (ParameterCredits == 2);
  result.command_queue_remaining_capacity = CommandQueue.Capacity() - CommandQueue.Size(); // If IsFull(), this will evaluate to zero. If IsEmpty(), it will evaluate to Capacity(), which happens to be 4.
  result.packer_reg_write_fifo_full = false; // This should never be true, but if it is, the next `PACR_SETREG` might be silently dropped.
  result.unpacker_reg_write_fifo_full = false; // This should never be true, but if it is, the next `UNPACR_NOP` performing a register write might be silently dropped.
  return result;
}

uint32_t CurrentThreadMovCmdBase() {
  if (CurrentThread is RISCV B or RISCV T0 or RISCV T1 or RISCV T2) {
    return MovCmdBase[CurrentThread];
  } else {
    return MovCmdBase[RISCV T0];
  }
}
```

The command processor itself can be modelled as an independent thread executing the following:
```c
void TDMA_RISC_Command_Processor() {
  for (;;) {
    while (CommandQueue.IsEmpty()) {
      wait;
    }
    uint32_t Cmd, Params[4];
    std::tie(Cmd, Params) = CommandQueue.Peek();
    uint32_t Opcode = Cmd & 0xff;
    switch (Opcode) {
    case 0x40: // Mover command
      uint32_t Src, Dst, Count, Mode;
      while (Mover.IsBusy()) {
        wait;
      }
      if (Cmd >> 31) {
        Src = CurrentThreadMovCmdBase() + ((Cmd >> 8) & 0xff);
        Dst = (Cmd >> 16) & 0xff;
        Count = (Cmd >> 24) & 0x3f;
        Mode = (Cmd >> 30) & 1 ? XFER_L1_L1 : XFER_L1_L0;
      } else {
        Src = Params[0];
        Dst = Params[1];
        Count = Params[2] & 0xffff;
        Mode = Params[3] & 3; // 0 = XFER_L0_L1, 1 = XFER_L1_L0, 2 = XFER_L0_L0, 3 = XFER_L1_L1
      }
      async Mover(Dst << 4, Src << 4, Count << 4, Mode);
      break;
    case 0x46: // Mover wait command
      while (Mover.IsBusy()) {
        wait;
      }
      break;
    case 0x66: // L1 write command (32b or 64b)
      if (Cmd >> 31) UndefinedBehaviour();
      else if ((Cmd & 0x600) != 0x600) UndefinedBehaviour();
      else {
        uint32_t Dst = Params[0];
        if (Dst >= (1024*1464)) UndefinedBehaviour(); // Dst must be an address in L1
        if (Cmd & 0x100) {
          async *(uint64_t*)Dst = (uint64_t(Params[3]) << 32) | uint64_t(Params[2]);
        } else {
          async *(uint32_t*)Dst = Params[2];
        }
      }
      break;
    case 0x89: // NOP command
      break;
    default:
      UndefinedBehaviour();
      break;
    }
    CommandQueue.Pop();
    if (!(Cmd >> 31)) {
      ParameterCredits += 1;
    }
  }
}
```

For the definition of the `Mover` function, see [the mover](Mover.md). Note the various `<< 4` in the call to the `Mover` function.

---

Primarily related to `PACR_SETREG` and `UNPACR_NOP` configuration:

```c
uint32_t PackRegAddrRaw;

void SetScaler(uint32_t starting_index, uint32_t values) {
  if (starting_index == 3) {
    // Low 16 bits of `values` used to configure some clock gater hysteresis.
    // Software should generally avoid changing these bits by using a pattern
    // along the lines of:
    // *RISCV_TDMA_REG_CLK_GATE_HYST = (*RISCV_TDMA_REG_CLK_GATE_HYST & 0xffff) | (new_scaler_value << 16);
    values >>= 16;
  }
  for (unsigned i = 0; i < 3 && (starting_index + i) < 4; ++i) {
    Packers.SetRegHiScaler[starting_index + i] = values & 0x1ff;
    values >>= 9;
  }
}

uint32_t ScalarsAndStatus(uint32_t which_unpacker) {
  uint32_t result = 0;
  for (unsigned i = 0; i < 3; ++i) {
    result |= Packers.SetRegHiScaler[i] << (i * 9);
  }
  for (unsigned i = 0; i < 4; ++i) {
    // These are the same control signals as STALLWAIT would use for
    // conditions C3 through C6, if the STALLWAIT was issued by Tensix
    // thread T2.
    if (Packers[i].IsBusyForThread(2)) result |= (1u << (27 + i));
  }
  if (Unpackers[which_unpacker].SetRegAcc & 0x10000) {
    // See UnpackerPackerAcc for the low 16 bits of SetRegAcc.
    result |= (1u << 31);
  }
  return result;
}

void SetPackRegAddr(uint32_t new_val) {
  PackRegAddrRaw = new_val;
  for (unsigned i = 0; i < 2; ++i) {
    uint32_t mid = (new_val >> (10 * i)) & 0x3ff;
    uint32_t hi = (new_val >> (20 + 2 * i)) & 3;
    Packers.SetRegBase[i] = (hi << 18) + (mid << 2);
  }
}

uint32_t MetadataFIFOStatus() {
  uint32_t result = PackRegAddrRaw << 8;
  for (unsigned i = 0; i < 4; ++i) {
    auto& fifo = Packers[i].MetadataFIFO;
    if (fifo.IsEmpty()) result |= 1u << (2 * i);
    if (fifo.IsFull()) result |= 2u << (2 * i);
  }
  return result;
}
```

---

Primarily related to sideband metadata generated by packers and unpackers:

```c
uint32_t PackerTileSize(uint32_t which_packer, uint32_t which_thread) {
  auto& Packer = Packers[which_packer];
  return Packer.LastThread == which_thread ? Packer.LastTileSize : 0;
}

void ResetPackerAccTileSize(uint32_t new_val) {
  for (unsigned i = 0; i < 4; ++i) {
    if (new_val.Bit[16 + i]) {
      Packers[i].AccTileSize[0] = 0;
      Packers[i].AccTileSize[1] = 0;
      Packers[i].AccTileSize[2] = 0;
      Packers[i].l1_dest_addr_offset = new_val & 0xffff; // Potentially used by the output address generator
    }
  }
}

uint32_t UnpackerPackerAcc(uint32_t which_packer, uint32_t which_thread) {
  uint16_t lo = Packers[which_packer].AccTileSize[which_thread];
  uint16_t hi = Unpackers[which_packer & 1].SetRegAcc & 0xffff;
  return (uint32_t(hi) << 16) + lo;
}
```

The `AllZeroFlags` metadata is computed by packers if [compression](TensixCoprocessor/Packers/Compression.md) is enabled, consisting of one bit per "compression row".

The `AccTileSize` state is updated like so when a packer finishes a tile (i.e. at the end of `PACR` instruction which has `Last` set to `true`):
```c
uint1_t StateID = ThreadConfig[CurrentThread].CFG_STATE_ID_StateID;
auto& CurrentPackerConfig = CurrentPacker.Config[StateID];

CurrentPacker.AccTileSize[CurrentThread] += CurrentPacker.LastTileSize;
if (CurrentPackerConfig.Add_tile_header_size) {
  CurrentPacker.AccTileSize[CurrentThread] += 1;
}
if (CurrentPackerConfig.Enable_out_fifo && !CurrentPacker.MetadataFIFO.IsFull()) {
  CurrentPacker.MetadataFIFO.Push({CurrentPacker.LastTileSize, CurrentPacker.AllZeroFlags});
}
```

Reading from memory locations which involve `MetadataFIFO.Peek()` will automatically wait if said FIFO is empty. On the other hand, reading from memory locations which involve `MetadataFIFO.Pop()` will immediately return undefined data if said FIFO is empty. As such, it is strongly recommended to read from the `Peek` address _before_ reading from the `Pop` address, or otherwise to inspect the result of `MetadataFIFOStatus()` before choosing to read from a `Pop` address.
