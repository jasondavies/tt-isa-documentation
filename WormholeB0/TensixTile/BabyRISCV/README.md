# "Baby" RISCVs

Each Tensix tile contains five RISCV cores. Collectively, these are called "baby" cores as they are relatively small 32-bit in-order single-issue cores, optimised for area and power efficiency rather than for high performance. Each RISCV core is intended to execute one RV32IM instruction per cycle, running at a clock speed of 1 GHz. The five cores are called RISCV B, RISCV T0, RISCV T1, RISCV T2, and RISCV NC, with the major differences between them being:

||RISCV B|RISCV T0|RISCV T1|RISCV T2|RISCV NC|
|---|---|---|---|---|---|
|**Controlling other RISCV cores**|Great|OK|OK|OK|Poor|
|**Tensix coprocessor access**|OK|Great|Great|Great|[Only via debug bus](PushTensixInstruction.md#debug-registers)|
|**Local data memory**|4 KiB RAM|2 KiB RAM|2 KiB RAM|2 KiB RAM|4 KiB RAM|
|**Local instruction memory**|2 KiB cache|2 KiB cache|½ KiB cache|2 KiB cache|½ KiB cache + 16 KiB RAM|
|**[GDB/Debug interface](DebugInterface.md)**|Yes|Yes|Yes|Yes|No|

If using TT-Metalium, data movement kernels run on RISCV B and RISCV NC, whereas compute kernels run on RISCV T0 (`UNPACK` part of kernel) and T1 (`MATH` part of kernel) and T2 (`PACK` part of kernel).

## Instruction set

The full RV32IM instruction set is implemented, with two caveats:
* The `fence` instruction is executed as if it were `nop`, and hence cannot be used to enforce memory ordering.
* The `ebreak` and `ecall` instructions [trigger a debug pause, in the same fashion as a hardware breakpoint](DebugInterface.md#ebreak-and-ecall-instructions).

Consult the RISCV specifications of "RV32I Base Integer Instruction Set" and "M Standard Extension for Integer Multiplication and Division" for full details of RV32IM, including instruction semantics and instruction encodings.

One bespoke instruction set extension is implemented: [`.ttinsn`](PushTensixInstruction.md#ttinsn-instruction-set-extension).

Invalid / unsupported RISCV instructions are silently executed as if they were _some_ other instruction - usually as if they were a `nop` instruction, but not always.

## Pipeline

![](../../../Diagrams/Out/BabyRISCV.svg)

All instructions execute by flowing down the pipeline: every instruction spends at least one cycle in the Integer Unit, at least one cycle in the Load/Store Unit, and at least one cycle in Retire Unit. Everything is in-order, except for the innards of the Load/Store Unit: instructions enter the Load/Store Unit in order, and leave the Load/Store Unit in order, but significant re-ordering can occur within the Load/Store Unit. This unit is also where all interesting interactions with the outside world happen: the Load/Store Unit _can_ access [L1](../L1.md) and local data RAM, but every other entry on its large outgoing mux represents an interesting device which has been mapped into its address space.

## Frontend

The Frontend is responsible for fetching instructions from memory, and is capable of sending one instruction per cycle to the Integer Unit. The Frontend _predicts_ all control flow, so instructions leaving the Frontend are _speculative_: the Integer Unit is responsible for reconciling predicted control flow with actual control flow, notifying the Frontend of actual control flow, and discarding any incorrectly predicted instructions.

Instructions can only be fetched and executed from L1 or from a core-local instruction RAM; instructions cannot be executed out of any other memory regions. Each RISCV has a little [instruction cache](InstructionCache.md) sitting between it and L1. Only RISCV NC has a core-local instruction RAM, and the Load/Store Unit is neither able to read nor write to this RAM; see [core-local instruction RAM](InstructionRAM.md) for details on how to populate it.

## Integer Unit

An instruction can enter the Integer Unit once the values of its register operands are known. These values can come from instructions which have already retired, or from an instruction as it moves between the Integer Unit and the Load/Store Unit, or from an instruction as it moves between the Load/Store Unit and the Retire Unit. However, if an instruction is sitting strictly _within_ the Load/Store Unit and unable to yet leave, then the value generated by that instruction is _not_ available, and any dependent instructions will _not_ be able to enter the Integer Unit.

Every instruction spends at least one cycle in the Integer Unit. Most instructions spend _exactly_ one cycle in the Integer Unit, the exceptions being:
* Multiply instructions (`mul`, `mulh`, `mulhsu`, `mulhu`) occupy the Integer Unit for two cycles, and the next instruction cannot enter the unit until the multiply instruction has finished.
* Divide instructions (`div`, `divu`, `rem`, `remu`) occupy the Integer Unit for a variable number of cycles, and the next instruction cannot enter the unit until the divide instruction has finished. The number of cycles is dependent upon the values of the dividend and the divisor:
  * When dividing by zero or one, two cycles are required.
  * When doing signed division or remainder of -2<sup>31</sup> by -1, two cycles are required.
  * In all other cases, between six and 33 cycles are required, dependent upon the magnitude of the dividend.
* Branch instructions (`jal`, `jalr`, `beq`, `bne`, `blt`, `bge`, etc) occupy the Integer Unit for one cycle, and this unit is where the Frontend's branch predictions get confirmed or rejected. A mispredicted branch causes a two cycle pipeline bubble, which from an external perspective looks like mispredicted branches occupy the Integer Unit for three cycles (plus additional cycles if the branch target is not in the instruction RAM or instruction cache).

There is a forwarding path allowing the result of the Integer Unit to be consumed by the very next instruction. This means that integer operations (other than multiply and divide) appear to execute with latency 1 and throughput 1.

## Load/Store Unit

Every instruction spends at least one cycle in the Load/Store Unit, though instructions other than loads or stores merely pass through it inert on their way to retirement. Instructions enter in order, and leave in order, but significant re-ordering can occur within the unit; see [memory ordering](MemoryOrdering.md) for details. A load instruction cannot leave the unit until its result has come back from the memory subsystem, and as instructions have to leave in order, there can be several instructions queued up behind a slow load. The capacity of this queue allows for up to eight instructions to sit within the Load/Store Unit at any time: the oldest non-retired load, plus (up to) the next seven instructions in program order.

The latency of a load instruction depends upon the memory region being accessed. A latency of `N` cycles means that `N - 1` independent instructions need to follow the load if the latency is to be entirely hidden. The minimum possible load latency is two cycles, due to all instructions spending at least one cycle in the Integer Unit and one cycle in the Load/Store Unit.

<table><thead><tr><th>Load address range</th><th>Load latency (cycles)</th><th>Maximum loads in flight</th></tr></thead>
<tr><td><a href="README.md#local-data-ram">Core-local data RAM</a></td><td>2</td><td>8</td></tr>
<tr><td><a href="Mailboxes.md">Mailboxes</a><br/><a href="PCBufs.md">PCBufs</a><br/><a href="TTSync.md">TTSync</a><br/><a href="../TensixCoprocessor/SyncUnit.md#semaphores">Tensix semaphores</a></td><td>≥ 3 (more if waiting on an empty FIFO or waiting for a TTSync event)</td><td rowspan="4">4 (in aggregate across all of these regions)</td></tr>
<tr><td><a href="../TensixCoprocessor/ScalarUnit.md#gprs">Tensix GPRs</a><br/><a href="../TensixCoprocessor/BackendConfiguration.md">Tensix backend configuration</a></td><td>≥ 4 (more in the case of access conflicts)</td></tr>
<tr><td><a href="../TDMA-RISC.md">TDMA-RISC&nbsp;configuration&nbsp;and&nbsp;command</a><br/><a href="../TileControlDebugStatus.md">Tile control / debug / status</a><br/>PIC configuration and status<br/>NoC 0 configuration and command<br/>NoC 1 configuration and command<br/>NoC&nbsp;overlay&nbsp;configuration&nbsp;and&nbsp;command</td><td>≥ 7 (more in the case of access conflicts)</td></tr>
<tr><td><a href="../L1.md">L1 scratchpad RAM (1464 KiB)</a></td><td>≥ 8 (more in the case of access port conflicts or bank conflicts)</td></tr>
</table>

Throughput of sustained loads is one per cycle if the load latency is less than five cycles. Otherwise, when the load latency is `N` cycles, the throughput of sustained loads is four such loads every `N - 1` cycles. In either case, this can require careful instruction scheduling to ensure that load latency is hidden via use of independent instructions.

Throughput of sustained stores to L1 is at most one store every five cycles. Other memory regions can achieve a throughput of one store every cycle (notwithstanding access conflicts or attempting to write to a full FIFO).

## Retire Unit

Every instruction spends exactly one cycle in the Retire Unit, which is where the result of the instruction (if any) gets persisted to the register file (GPRs). This unit is entirely invisible from an external perspective, as results of instructions are available for one cycle as they move from the Load/Store Unit to the Retire Unit, and the Retire Unit itself only takes one cycle to make the result permanently available.

## Memory map

The "NoC" column indicates which parts of the address space are made available to the NoC (and to the Tensix coprocessor) in addition to being available to RISCV cores.

<table><thead><tr><th>Name and address range</th><th>RISCV&nbsp;B</th><th>RISCV&nbsp;T0</th><th>RISCV&nbsp;T1</th><th>RISCV&nbsp;T2</th><th>RISCV&nbsp;NC</th><th>NoC</th></tr></thead>
<tr><td><code>MEM_L1_BASE</code><br/><code>0x0000_0000</code> to <code>0x0016_FFFF</code></td><td colspan="6"><a href="../L1.md">L1 scratchpad RAM (1464 KiB)</a></td></tr>
<tr><td><code>MEM_LOCAL_BASE</code><br/><code>0xFFB0_0000</code> to <code>0xFFB0_07FF</code></td><td rowspan="2"><a href="README.md#local-data-ram">RISCV B local data RAM</a></td><td><a href="README.md#local-data-ram">RISCV T0 local data RAM</a></td><td><a href="README.md#local-data-ram">RISCV T1 local data RAM</a></td><td><a href="README.md#local-data-ram">RISCV T2 local data RAM</a></td><td rowspan="2"><a href="README.md#local-data-ram">RISCV NC local data RAM</a></td><td rowspan="2">Unmapped</td></tr>
<tr><td><code>0xFFB0_0800</code> to <code>0xFFB0_0FFF</code></td><td colspan="3">Unmapped</td></tr>
<tr><td><code>RISCV_TDMA_REGS_START_ADDR</code><br/><code>0xFFB1_1000</code> to <code>0xFFB1_1FFF</code></td><td colspan="6"><a href="../TDMA-RISC.md">TDMA-RISC configuration registers and command interface</a></td></tr>
<tr><td><code>RISCV_DEBUG_REGS_START_ADDR</code><br/><code>0xFFB1_2000</code> to <code>0xFFB1_2FFF</code></td><td colspan="6"><a href="../TileControlDebugStatus.md">Tile control / debug / status registers</a></td></tr>
<tr><td><code>0xFFB1_3000</code> to <code>0xFFB1_3FFF</code></td><td colspan="6">PIC configuration and status registers</td></tr>
<tr><td><code>NOC0_REGS_START_ADDR</code><br/><code>0xFFB2_0000</code> to <code>0xFFB2_FFFF</code></td><td colspan="6"><a href="../../NoC/MemoryMap.md">NoC 0 configuration registers and command interface</a></td></tr>
<tr><td><code>NOC1_REGS_START_ADDR</code><br/><code>0xFFB3_0000</code> to <code>0xFFB3_FFFF</code></td><td colspan="6"><a href="../../NoC/MemoryMap.md">NoC 1 configuration registers and command interface</a></td></tr>
<tr><td><code>NOC_OVERLAY_START_ADDR</code><br/><code>0xFFB4_0000</code> to <code>0xFFB7_FFFF</code></td><td colspan="6">NoC overlay configuration registers and command interface</td></tr>
<tr><td><code>TENSIX_MOP_CFG_BASE</code><br/><code>0xFFB8_0000</code> to <code>0xFFB8_0023</code></td><td>Unmapped</td><td><a href="../TensixCoprocessor/MOPExpander.md#configuration">T0 MOP expander configuration</a></td><td><a href="../TensixCoprocessor/MOPExpander.md#configuration">T1 MOP expander configuration</a></td><td><a href="../TensixCoprocessor/MOPExpander.md#configuration">T2 MOP expander configuration</a></td><td colspan="2">Unmapped</td></tr>
<tr><td><code>MEM_NCRISC_IRAM_BASE</code><br/><code>0xFFC0_0000</code> to <code>0xFFC0_FFFF</code></td><td colspan="4">Unmapped</td><td><a href="InstructionRAM.md">RISCV NC local IRAM</a><br/>(Not accessible by Load/Store Unit)</td><td>Unmapped</td></tr>
<tr><td><code>REGFILE_BASE</code><br/><code>0xFFE0_0000</code> to <code>0xFFE0_0FFF</code></td><td><a href="../TensixCoprocessor/ScalarUnit.md#gprs">Tensix T0/T1/T2 GPRs</a></td><td><a href="../TensixCoprocessor/ScalarUnit.md#gprs">Tensix T0 GPRs</a></td><td><a href="../TensixCoprocessor/ScalarUnit.md#gprs">Tensix T1 GPRs</a></td><td><a href="../TensixCoprocessor/ScalarUnit.md#gprs">Tensix T2 GPRs</a></td><td colspan="2">Unmapped</td></tr>
<tr><td><code>INSTRN_BUF_BASE</code><br/><code>0xFFE4_0000</code> to <code>0xFFE4_FFFF</code></td><td><a href="PushTensixInstruction.md">Push Tensix T0 instruction</a>, after T0 MOP expander</td><td><a href="PushTensixInstruction.md">Push Tensix T0 instruction</a>, before T0 MOP expander</td><td><a href="PushTensixInstruction.md">Push Tensix T1 instruction</a>, before T1 MOP expander</td><td><a href="PushTensixInstruction.md">Push Tensix T2 instruction</a>, before T2 MOP expander</td><td colspan="2">Unmapped</td></tr>
<tr><td><code>INSTRN1_BUF_BASE</code><br/><code>0xFFE5_0000</code> to <code>0xFFE5_FFFF</code></td><td><a href="PushTensixInstruction.md">Push Tensix T1 instruction</a>, after T1 MOP expander</td><td colspan="5">Unmapped</td></tr>
<tr><td><code>INSTRN2_BUF_BASE</code><br/><code>0xFFE6_0000</code> to <code>0xFFE6_FFFF</code></td><td><a href="PushTensixInstruction.md">Push Tensix T2 instruction</a>, after T2 MOP expander</td><td colspan="5">Unmapped</td></tr>
<tr><td><code>PC_BUF_BASE</code><br/><code>0xFFE8_0000</code> to <code>0xFFE8_0003</code></td><td rowspan="3"><a href="PCBufs.md">PCBuf</a> from B to T0, B side</td><td><a href="PCBufs.md">PCBuf</a> from B to T0, T side</td><td><a href="PCBufs.md">PCBuf</a> from B to T1, T side</td><td><a href="PCBufs.md">PCBuf</a> from B to T2, T side</td><td colspan="2" rowspan="3">Unmapped</td></tr>
<tr><td><code>0xFFE8_0004</code> to <code>0xFFE8_001F</code></td><td><a href="TTSync.md">TTSync T0</a></td><td><a href="TTSync.md">TTSync T1</a></td><td><a href="TTSync.md">TTSync T2</a></td></tr>
<tr><td><code>0xFFE8_0020</code> to <code>0xFFE8_FFFF</code></td><td colspan="3"><a href="../TensixCoprocessor/SyncUnit.md#semaphores">Tensix semaphores</a></td></tr>
<tr><td><code>PC1_BUF_BASE</code><br/><code>0xFFE9_0000</code> to <code>0xFFE9_FFFF</code></td><td><a href="PCBufs.md">PCBuf</a> from B to T1, B side</td><td colspan="5">Unmapped</td></tr>
<tr><td><code>PC2_BUF_BASE</code><br/><code>0xFFEA_0000</code> to <code>0xFFEA_FFFF</code></td><td><a href="PCBufs.md">PCBuf</a> from B to T2, B side</td><td colspan="5">Unmapped</td></tr>
<tr><td><code>TENSIX_MAILBOX0_BASE</code><br/><code>0xFFEC_0000</code> to <code>0xFFEC_0FFF</code></td><td colspan="4" rowspan="4"><a href="Mailboxes.md">Mailboxes between pairs of RISCV cores</a></td><td colspan="2" rowspan="4">Unmapped</td></tr>
<tr><td><code>TENSIX_MAILBOX1_BASE</code><br/><code>0xFFEC_1000</code> to <code>0xFFEC_1FFF</code></td></tr>
<tr><td><code>TENSIX_MAILBOX2_BASE</code><br/><code>0xFFEC_2000</code> to <code>0xFFEC_2FFF</code></td></tr>
<tr><td><code>TENSIX_MAILBOX3_BASE</code><br/><code>0xFFEC_3000</code> to <code>0xFFEC_3FFF</code></td></tr>
<tr><td><code>TENSIX_CFG_BASE</code><br/><code>0xFFEF_0000</code> to <code>0xFFEF_FFFF</code></td><td colspan="4"><a href="../TensixCoprocessor/BackendConfiguration.md">Tensix backend configuration</a> (also includes some RISCV control registers)</td><td colspan="2">Unmapped</td></tr>
</table>

## Faults / exceptions

The baby RISCV cores cannot fault. Scenarios which might be expected to cause a fault are instead handled in some way:
* Unaligned memory accesses are silently rounded down to the nearest aligned address.
* Loads from unmapped memory will usually stall forever waiting for a read-response to come back from the memory subsystem.
* Stores to unmapped memory might stall forever, or might be silently discarded.
* RISCV `ecall` / `ebreak` instructions will pause the core, [as if a pause was requested via the GDB/Debug interface](DebugInterface.md#ebreak-and-ecall-instructions).
* Invalid / unsupported RISCV instructions are silently executed as if they were _some_ other instruction - usually as if they were a `nop` instruction, but not always.

## Local data RAM

Each baby RISCV has either 4 KiB (B, NC) or 2 KiB (T0, T1, T2) of local data RAM, starting at address `MEM_LOCAL_BASE`. Each one of these five RAMs is only accessible using load or store instructions from the one RISCV associated with it. Access to this RAM is low latency, and accesses never suffer from contention. A load from local RAM has a latency of two cycles, meaning that so long as the one instruction immediately after the load is independent of the load result, the latency of the load is entirely hidden. In contrast, a load from L1 has a latency of at least eight cycles: seven independent instructions are required to fully hide the latency. Software is _strongly_ encouraged to place the call stack in this RAM, along with any thread-local variables and any frequently-used read-only global variables.
