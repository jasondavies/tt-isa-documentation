# Ethernet TX and RX

Each Ethernet tile contains Ethernet transmit and receive subsystems. From a device software perspective, the transmit subsystem consists of two TX queues, and the receive subsystem consists of two RX queues. Software is expected to use these queues rather than directly interacting with the Ethernet MAC / PCS / PHY. The two subsystems are described simultaneously, as they interact with each other.

Note that firmware provides a higher-level [baseline data movement service](BaselineDataMovementService.md) for host software to use.

## RX Queues

Each Ethernet tile has two Ethernet RX queues. Each RX queue supports two modes:
* Raw RX mode
* TT-link RX mode

In raw RX mode, the RX queue is configured to specify an RX buffer in L1, and then the RX queue will append the bodies of incoming packets to that buffer, in order of arrival. Ethernet headers and footers are stripped, and there are no frame markers, so this mode is suitable for sending an arbitrary stream of bytes between two directly-connected Wormhole ASICs, but it is not suitable for more general use.

> [!TIP]
> The newer Blackhole product line has a significantly improved raw RX mode, which should be more suitable for using a Blackhole card as a general-purpose NIC.

In TT-link RX mode, the RX queue expects to exclusively receive TT-link packets. Other types of packet will probably be discarded due to invalid headers or invalid sequence numbers (though this is not guaranteed, so other types of packet should not be sent to an RX queue operating in TT-link RX mode). All types of TT-link packet include a pair of 8-bit sequence numbers, and then vary based on the particular type of TT-link packet:
* **Sequence number update packet:** Contains just sequence numbers, no additional data.
* **MMIO write packet:** Contains a 32-bit MMIO address and 32 bits of data. Upon receiving this kind of packet, the RX queue will perform an MMIO write of the specified data to the specified address.
* **L1 write packet:** Contains an L1 address and a variable amount of data. Upon receiving this kind of packet, the RX queue will write the data to the specified address in L1.
* **NoC Overlay packet:** Similar to an L1 write packet, but also has some additional metadata required to support [NoC Overlay streams](../NoC/Overlay/TransferBetweenTiles.md).

> [!WARNING] 
> The two RX queues in each Ethernet tile are not quite identical, as RX queue #1 does not support receiving TT-link MMIO write packets nor TT-link NoC Overlay packets.

## TX Queues

Each Ethernet tile has two Ethernet TX queues. Each TX queue supports two modes:
* Raw TX mode
* TT-link TX mode

In raw TX mode, software can pass arbitrary Ethernet packets to the TX queue, which will send them out over the wire. The TX queue will transmit raw packets in the order they were enqueued, but once on the wire, the packets might be dropped or reordered (or in extreme cases, duplicated). Note that if direct attach cables are used between two Tenstorrent devices, with no Ethernet switches or routers between them, then drops can still happen, but reordering / duplication should not.

In TT-link TX mode, the TX queue transmits TT-link packets. These packets have headers and sequence numbers, and the TX queue will repeatedly re-send packets until it receives acknowledgement of their receipt (meanwhile, the recipient will discard packets with duplicate sequence numbers). This requires that the TX queue keep a copy of the packet metadata for all unacknowledged packets, and requires that it re-fetch the packet body from L1 for every re-send attempt. Software can instruct the TX queue to send MMIO write packets or L1 write packets, whereas sequence number update packets are generated internally when there are no other packets for them to piggy-back on, and NoC Overlay packets are generated by the [NoC Overlay](../NoC/Overlay/README.md).

> [!WARNING] 
> The two TX queues in each Ethernet tile are not quite identical, as TX queue #1 does not support transmitting TT-link MMIO write packets nor TT-link NoC Overlay packets.

## Associating TX queues with RX queues

It is expected that local TX queue #0 is communicating with some remote RX queue #0, and that local TX queue #1 is communicating with some remote RX queue #1. Firmware will configure things as necessary to ensure this: it will set an appropriate destination MAC address on every TX queue, and configure the Ethernet hardware to route incoming packets to RX queues based on MAC address.

On n300 boards, the "left" (i.e. PCIe connected) ASIC always has:
* Ethernet tile E8 (at NoC #0 coordinates `9,6`) connected to the "right" ASIC Ethernet tile E0 (at NoC #0 coordinates `9,0`).
* Ethernet tile E9 (at NoC #0 coordinates `1,6`) connected to the "right" ASIC Ethernet tile E1 (at NoC #0 coordinates `1,0`).

Firmware will configure RX queue #0 and TX queue #0 to be operating in TT-link mode, so customer software can always assume this.

## TX Queue Memory Map

TX queue #0 has `TXQ_BASE` of `0xFFB9_0000`, and TX queue #1 has `TXQ_BASE` of `0xFFB9_1000`.

|Address|Purpose|
|---|---|
|[`TXQ_BASE + ETH_TXQ_CTRL`](#eth_txq_ctrl)<br/>`0xFFB9_0000` or `0xFFB9_1000`|Miscellaneous configuration bits|
|[`TXQ_BASE + ETH_TXQ_CMD`](#eth_txq_cmd)<br/>`0xFFB9_0004` or `0xFFB9_1004`|Write to request that a packet be transmitted, read to confirm that the request has been enqueued and thus the TX queue is ready for the next request|
|`TXQ_BASE + MAX_PKT_SIZE_BYTES_OFFSET`<br/>`0xFFB9_000C` or `0xFFB9_100C`|Maximum packet size (in bytes). When `ETH_TXQ_TRANSFER_SIZE_BYTES` exceeds this value, the TX queue will automatically split outgoing packets|
|<code>TXQ_BASE&nbsp;+&nbsp;ETH_TXQ_TRANSFER_START_ADDR</code><br/>`0xFFB9_0014` or `0xFFB9_1014`|**TT-link L1 write packets:** The L1 address in the local tile to read from (must be 16-byte aligned)<br/>**TT-link MMIO write packets:** Ignored (data instead comes from `ETH_TXQ_REMOTE_REG_DATA`)<br/>**Raw packets:** The L1 address in the local tile to read from|
|`TXQ_BASE + ETH_TXQ_TRANSFER_SIZE_BYTES`<br/>`0xFFB9_0018` or `0xFFB9_1018`|**TT-link L1 write packets:** The number of bytes to read from the local L1 and write to the remote L1 (must be a multiple of 16)<br/>**TT-link MMIO write packets:** Ignored (length is always 4 bytes)<br/>**Raw packets:** The number of bytes to read from the local L1 and write to the remote L1|
|`TXQ_BASE + ETH_TXQ_DEST_ADDR`<br/>`0xFFB9_001C` or `0xFFB9_101C`|**TT-link L1 write packets:** The remote L1 address to write to (must be 16-byte aligned)<br/>**TT-link MMIO write packets:** The remote MMIO address to write to (must be 4-byte aligned)<br/>**Raw packets:** Ignored (the receiving RX queue controls the address)|
|`TXQ_BASE + ETH_TXQ_TRANSFER_CNT`<br/>`0xFFB9_0030` or `0xFFB9_1030`|Counter which hardware increments by one every time hardware transitions `ETH_TXQ_CMD` from non-zero to zero|
|`TXQ_BASE + ETH_TXQ_PKT_START_CNT`<br/>`0xFFB9_0034` or `0xFFB9_1034`|Counter which hardware increments by one every time it starts sending a packet|
|`TXQ_BASE + ETH_TXQ_PKT_END_CNT`<br/>`0xFFB9_003C` or `0xFFB9_103C`|Counter which hardware increments by one every time it finishes sending a packet|
|`TXQ_BASE + ETH_TXQ_WORD_CNT`<br/>`0xFFB9_0040` or `0xFFB9_1040`|Counter which hardware increments by one for every 16 bytes (or part thereof) transmitted|
|`TXQ_BASE + ETH_TXQ_REMOTE_REG_DATA`<br/>`0xFFB9_0044` or `0xFFB9_1044`|**TT-link L1 write packets:** Ignored<br/>**TT-link MMIO write packets:** The 32 bits of data to write<br/>**Raw packets:** Ignored|
|`TXQ_BASE + ETH_TXQ_REMOTE_SEQ_TIMEOUT`<br/>`0xFFB9_0048` or `0xFFB9_1048`|After a TT-link packet has been transmitted, if it remains unacknowledged for this many cycles, it'll be re-sent|
|<code>TXQ_BASE&nbsp;+&nbsp;ETH_TXQ_LOCAL_SEQ_UPDATE_TIMEOUT</code><br/>`0xFFB9_004C` or `0xFFB9_104C`|When `ETH_TXQ_CTRL` indicates that TT-link sequence number update packets should be sent, the frequency (in cycles) at which they should be sent|
|[`TXQ_BASE + ETH_TXQ_DEST_MAC_ADDR_HI`](#mac-addresses)<br/>`0xFFB9_0050` or `0xFFB9_1050`|Destination MAC address (last two octets, little-endian) for all transmitted packets|
|[`TXQ_BASE + ETH_TXQ_DEST_MAC_ADDR_LO`](#mac-addresses)<br/>`0xFFB9_0054` or `0xFFB9_1054`|Destination MAC address (first four octets, little-endian) for all transmitted packets|
|[`TXQ_BASE + ETH_TXQ_SRC_MAC_ADDR_HI`](#mac-addresses)<br/>`0xFFB9_0058` or `0xFFB9_1058`|Source MAC address (last two octets, little-endian) for all transmitted packets|
|[`TXQ_BASE + ETH_TXQ_SRC_MAC_ADDR_LO`](#mac-addresses)<br/>`0xFFB9_005C` or `0xFFB9_105C`|Source MAC address (first four octets, little-endian) for all transmitted packets|
|`TXQ_BASE + ETH_TXQ_ETH_TYPE`<br/>`0xFFB9_0060` or `0xFFB9_1060`|Ethertype for transmitted packets, when `ETH_TXQ_CTRL` indicates an ethertype should be included (otherwise a length is included)|

### `ETH_TXQ_CTRL`

|First&nbsp;bit|#&nbsp;Bits|Name|Purpose|
|--:|--:|---|---|
|0|1|`ETH_TXQ_CTRL_KEEPALIVE`|If `true`, a TT-link sequence number update packet will be transmitted every `ETH_TXQ_LOCAL_SEQ_UPDATE_TIMEOUT` cycles (unless some other TT-link packet was sent in that period). If `false`, TT-link sequence number update packets will not be transmitted. This effectively serves as the configuration bit controlling whether the TX queue is operating in raw TX mode or TT-link TX mode, as regular TT-link packets are strongly advised in TT-link TX mode, and strongly discouraged in raw TX mode.|
|1|1|Reserved|Should be zero|
|2|1|`ETH_TXQ_CTRL_USE_TYPE`|If `true`, transmitted packets include the ethertype specified in `ETH_TXQ_ETH_TYPE`. If `false`, transmitted packets instead include their length.|
|3|1|`ETH_TXQ_CTRL_DIS_DROP`|If TT-link is in use, should be set to `true` to mitigate a hardware bug. No effect if TT-link is not in use.|
|4|28|Reserved|Can take any value|

### `ETH_TXQ_CMD`

Write a value of `1` to request that the TX queue transmit a raw packet. The source L1 address and length should have been set in `ETH_TXQ_TRANSFER_START_ADDR` and `ETH_TXQ_TRANSFER_SIZE_BYTES` respectively. Following the write to `ETH_TXQ_CMD`, software should hold the values of these two fields constant. Hardware will change the value of `ETH_TXQ_CMD` back to zero once it has finished reading the packet data from L1, after which software is free to change `ETH_TXQ_TRANSFER_START_ADDR` and `ETH_TXQ_TRANSFER_SIZE_BYTES`.

Write a value of `2` to request that the TX queue transmit a TT-link L1 write packet. The properties of the packet should have been set in `ETH_TXQ_TRANSFER_START_ADDR`, `ETH_TXQ_TRANSFER_SIZE_BYTES`, and `ETH_TXQ_DEST_ADDR`. Following the write to `ETH_TXQ_CMD`, software should hold the values of all these fields constant. Hardware will immediately change the value of `ETH_TXQ_CMD` to `1`, and then change it to `0` once it has latched the packet metadata, after which software is free to change the fields again. Note that hardware does not provide an indication of when it has finished reading from L1, and it may need to read the packet data out of L1 several times if re-sends are required.

Write a value of `4` to request that the TX queue transmit a TT-link MMIO write packet (TX queue #0 only). The properties of the packet should have been set in `ETH_TXQ_DEST_ADDR` and `ETH_TXQ_REMOTE_REG_DATA`. Following the write to `ETH_TXQ_CMD`, software should hold the values of these two fields constant. Hardware will immediately change the value of `ETH_TXQ_CMD` to `1`, and then change it to `0` once it has latched the packet metadata, after which software is free to change the fields again.

### MAC Addresses

A MAC address in canonical form `12:34:56:78:9A:BC` is configured by setting `MAC_ADDR_LO` to `0x78563412` and `MAC_ADDR_HI` to `0xBC9A`. Note that firmware typically uses the MAC addresses `AA:00:00:00:00:00` and `AB:00:00:00:00:00`.

## RX Queue Memory Map

RX queue #0 has `RXQ_BASE` of `0xFFB9_2000`, and RX queue #1 has `RXQ_BASE` of `0xFFB9_3000`.

|Address|Purpose|
|---|---|
|[`RXQ_BASE + ETH_RXQ_CTRL`](#eth_rxq_ctrl)<br/>`0xFFB9_2000` or `0xFFB9_3000`|Miscellaneous configuration bits|
|`RXQ_BASE + ETH_RXQ_BUF_PTR`<br/>`0xFFB9_2008` or `0xFFB9_3008`|**Raw RX mode:** The offset (in bytes) within the RX buffer where the body of the next incoming packet will be written. Software can safely read up to `ETH_RXQ_BUF_PTR - ETH_RXQ_OUTSTANDING_WR_CNT * 32`; the gap between the two represents data which has been received from the network but not yet committed to L1.|
|<code>RXQ_BASE&nbsp;+&nbsp;ETH_RXQ_BUF_START_WORD_ADDR</code><br/>`0xFFB9_200C` or `0xFFB9_300C`|**Raw RX mode:** The RX buffer starts at address `ETH_RXQ_BUF_START_WORD_ADDR << 4` in L1|
|`RXQ_BASE + ETH_RXQ_BUF_SIZE_WORDS`<br/>`0xFFB9_2010` or `0xFFB9_3010`|**Raw RX mode:** The size of the RX buffer is `ETH_RXQ_BUF_SIZE_WORDS << 4` bytes|
|`RXQ_BASE + ETH_RXQ_WORD_CNT`<br/>`0xFFB9_2014` or `0xFFB9_3014`|Counter which hardware increments by one for every 16 bytes (or part thereof) received. This includes both packet headers and bodies, and includes any packets received but then discarded. The counter is incremented after the data has been received from the network, but before it has been committed to L1.|
|`RXQ_BASE + ETH_RXQ_PKT_END_CNT`<br/>`0xFFB9_2028` or `0xFFB9_3028`|Counter which hardware increments by one for every received packet. This includes any packets received but then discarded. The counter is incremented after the end of the ethernet frame has been observed, but possibly before the entire packet body has been committed to L1.|
|`RXQ_BASE + ETH_RXQ_LOCAL_RX_SEQ_NUM`<br/>`0xFFB9_2040` or `0xFFB9_3040`|**TT-link RX mode:** The next sequence number we expect to receive|
|`RXQ_BASE + ETH_RXQ_REMOTE_RX_SEQ_NUM`<br/>`0xFFB9_2044` or `0xFFB9_3044`|**TT-link RX mode:** The sequence acknowledgement number contained within the most recently received TT-link packet (the TX queue uses this to confirm receipt of transmitted TT-link packets; the value is available here mainly for debugging purposes)|
|[`RXQ_BASE + ETH_RXQ_TILE_HEADER_FORMAT`](#eth_rxq_tile_header_format)<br/>`0xFFB9_2048` or `0xFFB9_3048`|**TT-link RX mode:** Additional configuration for NoC Overlay packets|
|`RXQ_BASE + ETH_RXQ_PACKET_DROP_CNT`<br/>`0xFFB9_204C` or `0xFFB9_304C`|Counter which hardware increments by one for every packet which is received but then discarded (e.g. due to sequence number mismatch in TT-link RX mode, or due to RX buffer full in raw RX mode)|
|`RXQ_BASE + ETH_RXQ_OUTSTANDING_WR_CNT`<br/>`0xFFB9_2050` or `0xFFB9_3050`|Read-only. `ETH_RXQ_OUTSTANDING_WR_CNT * 32` is (an upper bound on) the number of bytes which have been received from the network but not yet committed to L1.|

### `ETH_RXQ_CTRL`

|First&nbsp;bit|#&nbsp;Bits|Name|Purpose|
|--:|--:|---|---|
|0|1|Reserved|Should be zero|
|1|1|`ETH_RXQ_CTRL_PACKET_MODE`|If `true`, all received packets are assumed to be TT-link packets (i.e. RX queue operating in TT-link RX mode). If `false`, all received packets will be appended to the RX buffer (i.e. RX queue operating in raw RX mode).|
|2|1|`ETH_RXQ_CTRL_BUF_WRAP`|**Raw RX mode:** If `true`, hardware will automatically reset `ETH_RXQ_BUF_PTR` to zero when it hits `ETH_RXQ_BUF_SIZE_WORDS << 4`. If `false`, hardware will instead drop incoming data once `ETH_RXQ_BUF_PTR == ETH_RXQ_BUF_SIZE_WORDS << 4`.|
|3|1|`ETH_RXQ_CTRL_FORCE_BPRESSURE`|If `true`, the RX queue indicates to the MAC / PCS / PHY that it does not want to receive any packets. Should be set to `false` for normal operation.|
|4|28|Reserved|Can take any value|

### `ETH_RXQ_TILE_HEADER_FORMAT`

This serves the same purpose as [`STREAM_MSG_HEADER_FORMAT_REG_INDEX`](../NoC/Overlay/README.md#stream_msg_header_format_reg_index), just for TT-link NoC Overlay packets received over Ethernet, rather than NoC Overlay packets received over the NoC.

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|7|Byte offset of least significant bit of message length field within message header. Note that this is a byte offset, whereas in `STREAM_MSG_HEADER_FORMAT_REG_INDEX`, the corresponding field is a bit offset|
|7|7|Bit width of message length field within message header|
|14|18|Reserved|Writes ignored, reads as zero|

## RX Queue Memory Ordering

**Raw RX mode**: Packet bodies are appended to the RX buffer in packet arrival order. The various writes to L1 can happen in an arbitrary order, but software can use a combination of `ETH_RXQ_BUF_PTR` and `ETH_RXQ_BUF_SIZE_WORDS` to determine when the writes are complete.

**TT-link RX mode, MMIO write packets:** Each packet specifies one MMIO write. The writes are sent into the MMIO subsystem in packet transmission order. If consecutive packets are to the same MMIO device, then ordering is maintained all the way through to the device.

**TT-link RX mode, L1 write packets:** Each packet specifies some number of 16-byte writes to L1. Each individual 16-byte write is atomic, but the various writes to L1 can happen in a somewhat arbitrary order, and writes from consecutive packets can sometimes interleave. That said, _some_ guarantees are provided:
* Each 16-byte write is assigned to either stream #0 or stream #1.
* Within each packet, assignments to the same stream are performed in ascending address order.
* Each stream is drained out to L1 in assignment order (first in, first out).
* Consecutive packets perform their assignments in order of packet transmission: all of the 1<sup>st</sup> packet's assignments happen before any of the 2<sup>nd</sup> packet's assignments.
* If a packet consists of at most two 16-byte writes, all writes are assigned to stream #0.
* If a packet consists of more than two 16-byte writes, the lowest 32 bytes (in address order) are assigned to stream #0, the next 16 bytes are assigned to stream #1, the next 16 bytes are to stream #0, and the assignment continues alternating between streams for each subsequent 16 bytes.

**TT-link RX mode, NoC Overlay packets:** Each packet specifies some number of 16-byte writes to L1. The NoC Overlay is notified of the writes after the data has been committed to L1, and these notifications happen in-order, making the exact order of writes irrelevant.

Note that no guarantees are provided between different kinds of packet, nor between packets received on different RX queues, nor between packets received by different Ethernet tiles.
