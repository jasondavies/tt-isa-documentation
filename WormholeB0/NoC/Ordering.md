# NoC Ordering

## Ordering properties of a single packet

A single write request packet or read response packet will involve reading some bytes out of the address space of one tile, and writing those bytes in to the address space of another tile. When the reads or writes are against a tile's [L1](../TensixTile/L1.md), they will be broken up in to aligned 16 byte units, where each read of 16 bytes is atomic, and each write of 16 bytes is atomic, but the various reads could happen in any order, and the various writes could also happen in any order, and the reads / writes can be interleaved with other agents acting on L1. Software can inspect [counters](Counters.md) to determine once _all_ the reads have happened or _all_ the writes have happened, but should not assume anything about the order in which the individual reads or writes happen.

## Ordering properties of two packets

If two unicast packets have the same source and destination, and travel on the same NoC, then both packets will take the same route from source to destination. If two broadcast packets have the same source and same destination rectangle and same value of `NOC_CMD_BRCST_XY` and travel on the same NoC, then both packets will use the same tree of routes from source to destinations.

If two packets coincide for part (or all) of their route, and at every hop along that route, both are assigned the same virtual channel number for that hop, then no reordering nor interleaving will happen between the two packets as they transit the common part of their route: whichever packet enters the common part first will enter entirely before any of the 2<sup>nd</sup> packet can enter, and will leave the other end entirely before any of the 2<sup>nd</sup> packet can leave. This applies to all types of hop: router to router hops are the most common, but it also applies to the initial hop from an NIU to a router, and to the final hop from a router to an NIU. Software has a few ways of controlling virtual channel number assignment for request packets:
1. If the `NOC_CMD_VC_STATIC` flag is set: software dictates the virtual channel number used for the first hop from NIU to router, and the only part of the number that routers are allowed to change between hops is the dateline bit. The places where this bit flips are statically determined based on the route of the packet, and [the route itself is statically determined](RoutingPaths.md) based on the source and destination and `NOC_CMD_BRCST_XY` flag of the packet.
2. If the `NOC_CMD_VC_LINKED` flag is set: hardware can choose the virtual channel number used for the first hop of the first request, and hardware can choose to flip the buddy bit and/or the dateline bit at any router, but subsequent request packets in the same transaction (which must be from the same source to the same destination(s), and with the same value of `NOC_CMD_BRCST_XY`) will use the same virtual channel number for the first hop, and will have their buddy bit and/or dateline bit flipped in exactly the same places as per the first request packet. Note that this flag has additional effects beyond just controlling virtual channel number assignment.
3. When using [NIU request initiators](MemoryMap.md#niu-request-initiators), the order in which software writes to `NOC_CMD_CTRL` determines the order in which those requests will be assigned a virtual channel number for the first hop, and if two requests are assigned the same number (for example because of `NOC_CMD_VC_STATIC` or `NOC_CMD_VC_LINKED`), the order in which software writes to `NOC_CMD_CTRL` determines the order in which those requests leave the NIU.

Software has no way of controlling virtual channel number assignment for response / acknowledgement packets (their class bits will always be `0b11`, but their buddy bit can flip at any router), so these types of packets can always get reordered or interleaved. If software is expecting several such packets to arrive, it can use [counters](Counters.md) to determine once they have _all_ fully arrived, but it should not expect them to arrive in any particular order. It can only wait for a subset of such packets to arrive when the packets in question manipulate different counters.

The final place of interest is the recipient NIU, which receives a request packet, acts upon it, and optionally sends a response / acknowledgement packet. The recipient NIU can be acting on up to 12 different request packets (and 4 different response packets) simultaneously: one per virtual channel number (based on the virtual channel number used for the final hop from router to NIU). If two requests arrive on different virtual channels, then arbitrary reordering and interleaving can happen in the processing of those requests. On the other hand, if two packets arrive on the same virtual channel, one after the other, then there are some ordering guarantees:
1. If the 1<sup>st</sup> packet is a write request, and the 2<sup>nd</sup> packet is a read request, then all of the writes from the 1<sup>st</sup> packet will be committed to memory before any of the reads for the 2<sup>nd</sup> packet start.
2. If the 1<sup>st</sup> packet is a read request with `NOC_CMD_VC_LINKED` set, and the 2<sup>nd</sup> packet is any kind of request, then all of the memory reads for the 1<sup>st</sup> packet will be performed before any of the reads or writes from the 2<sup>nd</sup> packet.
3. If the 1<sup>st</sup> packet is an atomic request with `NOC_CMD_RESP_MARKED` set, and the 2<sup>nd</sup> packet is also an atomic request, then the atomic operation from the 1<sup>st</sup> packet will complete before the atomic operation from the 2<sup>nd</sup> packet starts.
4. If both packets are write requests to MMIO addresses, the write for the 1<sup>st</sup> packet will be sent to the relevant MMIO device before the write for the 2<sup>nd</sup> packet is sent to the relevant MMIO device. If the two requests are to the same MMIO device, ordering will be maintained all the way to the device, which will process the requests in order.
5. If both packets are read requests, and either packet is reading from an MMIO address, the read for the 1<sup>st</sup> packet will finish before the read for the 2<sup>nd</sup> packet starts.

## Stronger ordering

If software requires stronger ordering than what is described in the above sections, then it will have to issue a request, wait for the response to arrive, and only then issue the next request. Such an approach will negatively impact both latency and throughput. This is also the only approach if software needs ordering between requests which travel on different NoCs.

## Interaction with PCIe

The PCI Express tile provides two-way translation between NoC transactions and PCIe transactions. In the host-to-device direction, a host-initiated PCIe transaction is first translated to an AXI transaction, which is then translated to a NoC transaction. The translation to AXI always preserves PCI Express semantics, whereas several TLB configuration bits exist to control the ordering semantics of the latter translation (and these bits can be different for different TLBs):

|Configuration bit|Notes|
|---|---|
|Broadcast|If `true`, host writes are turned into NoC broadcasts (c.f. `NOC_CMD_BRCST_PACKET`). There is no way to specify an equivalent to `NOC_CMD_PATH_RESERVE`, so no path reservation happens. There is no way to specify an equivalent to `NOC_CMD_BRCST_XY`, so the broadcast will always use [X as the major axis](RoutingPaths.md#broadcast-routes-x-as-major-axis). There is no way to specify an equivalent to `NOC_CMD_BRCST_SRC_INCLUDE`, but none is required, as the PCI Express tile is always opted out of receiving broadcasts.|
|Ordering mode strict|If `true`, the PCI Express tile will follow AXI ordering rules when translating AXI transactions to NoC transactions. These rules require that reads do not reorder or interleave with other reads (assuming that the read requests have the same tag), and require that writes do not reorder or interleave with other writes (assuming that the write requests have the same tag). Following these rules severely limits how many NoC transactions the PCI Express tile can have in flight at any time. If `false`, AXI ordering rules are ignored: the PCI Express tile can have many transactions in flight at once, and the corresponding packets can reorder and/or interleave as they transit the NoC. These AXI ordering rules are stronger than the PCI Express ordering rules, so PCI Express ordering is still respected when this bit is `false`.|
|Ordering mode posted writes|If `true`, the PCI Express tile will return an AXI write acknowledgement for write requests as soon as the write data has entered the NoC. If `false`, the PCI Express tile will set the equivalent of `NOC_CMD_RESP_MARKED` on write requests, and only return an AXI write acknowledgement once the PCI Express tile receives the write acknowledgement from the NoC (or, for broadcasts, receives a write acknowledgement from _every_ recipient). When set to `true`, PCI Express ordering rules are no longer followed, as the PCI Express to AXI translation layer relies on correct write acknowledgements to enforce the PCI Express requirement that a (posted) write request followed by a read request is not reordered to end up with the read first. Software can set this to `true` if it does not require PCI Express ordering rules to be followed (for example if software does not perform any reads through the PCI Express tile).|
|Linked|This is similar to `NOC_CMD_VC_LINKED`. If the host issues a read through a TLB with this bit set, the read will become part of a multi-request transaction, and the next read issued by the host (through any TLB) will be part of that transaction. The host must subsequently issue a read though a TLB _without_ this bit set to emit a request which is the last request in the transaction. If the host issues a non-broadcast write through a TLB with this bit set, the write will become part of a multi-request transaction, and the next non-broadcast write issued by the host (through any TLB) will be part of that transaction. The host must subsequently issue a non-broadcast write though a TLB _without_ this bit set to emit a request which is the last request in the transaction. If the host issues a broadcast write through a TLB with this bit set, the write will become part of a multi-request transaction, and the next broadcast write issued by the host (through any TLB) will be part of that transaction. The host must subsequently issue a broadcast write though a TLB _without_ this bit set to emit a request which is the last request in the transaction. In all cases, all of the requests within a transaction must have the same destination tile(s). Each of these transactions behaves in the usual way for `NOC_CMD_VC_LINKED`: the first request packet in the NoC transaction can have its buddy bit and/or dateline bit flipped at any router, but subsequent request packets in the same transaction will have their buddy bit and/or dateline bit flipped in exactly the same places as per the first request packet in the transaction. Also, as per the usual `NOC_CMD_VC_LINKED` semantics, the virtual channel number used at each hop remains reserved for exclusive use by subsequent request packets of the same transaction. The major difference to NIU request initiators is that a regular NIU can only have one multi-request transaction in flight at a time and can put a mixture of request types in that transaction, whereas the PCI Express tile can have up to three multi-request transactions in flight and will not put different request types in the same transaction. Software is discouraged from setting this bit.|
|Static|This is identical to `NOC_CMD_VC_STATIC`. There are no configuration bits for specifying the exact virtual channel number though; instead, for the first hop from PCI Express tile NIU to NoC router, the PCI Express tile always sets the buddy bit to `0` for writes and to `1` for reads, and always sets the class bits to `0b10` for broadcast writes and to `0b00` otherwise.|

In the device-to-host direction, a NoC transaction is translated to one or more AXI transactions (to satisfy the maximum transaction size constraint of AXI, and to ensure that AXI transaction addresses do not cross a 4K boundary), and then each AXI transaction is translated to one or more PCIe transactions (for example to satisfy the maximum transaction size constraint of PCIe). The translation from NoC to AXI will serialise all read requests (i.e. all read requests will be given the same AXI tag), and will serialise write requests when they arrive on the same virtual channel number (i.e. write requests will use the virtual channel number as their AXI tag). The translation from AXI to PCI Express will cause all writes to become posted writes.
