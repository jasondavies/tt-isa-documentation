# Ethernet TX and RX

Each Ethernet tile contains Ethernet transmit and receive subsystems. From a device software perspective, the transmit subsystem consists of three separate TX queues and then a shared TX header table, and the receive subsystem consists of a shared RX classifier and then three separate RX queues. Software is expected to use these queues and shared parts rather than directly interacting with the Ethernet MAC / PCS / PHY. The subsystems are described simultaneously, as they interact with each other.

## RX Classifier

The RX classifier inspects all incoming Ethernet frames and decides whether to drop or keep the frame. If keeping the frame, it also decides:
* Whether to remove VLAN tags and IP/UDP headers from the frame.
* Whether to prepend an extra 4 or 8 bytes of metadata at the start of the frame (before the destination MAC address).
* Whether to record an RX timestamp for the frame (kept in a separate small FIFO, which software can pop from).
* Which RX queue to deliver the frame to.

## RX Queues

Each Ethernet tile has three Ethernet RX queues. Each RX queue supports two modes:
* Raw RX mode
* TT-link RX mode

In raw RX mode, the RX queue is configured to specify an RX buffer in L1, and then the RX queue will append incoming frames (after any modifications performed by the RX classifier) to that buffer. Optionally, some number of bytes can be stripped from the start of each frame. The RX queue concatenates all frames to form an amorphous stream of bytes, but metadata inserted by the RX classifier can allow frame boundaries to be reconstructed.

In TT-link RX mode, the RX queue expects to exclusively receive TT-link packets. Frames as delivered to the RX queue are expected to contain 14 bytes of Ethernet header (destination and source MAC addresses, then two bytes ethertype or length), followed immediately by 18 bytes of TT-link header, followed immediately by the TT-link payload (some multiple of 16 bytes). Any additional VLAN tags or IP/UDP headers need to have been removed by the RX classifier, and packets other than TT-link packets need to have been filtered out by the RX classifier. All types of TT-link packet include a pair of 8-bit sequence numbers, and then vary based on the particular type of TT-link packet:
* **Sequence number update packet:** Contains just sequence numbers, no additional data.
* **MMIO write packet:** Contains a 32-bit MMIO address and 32 bits of data. Upon receiving this kind of packet, the RX queue will perform an MMIO write of the specified data to the specified address.
* **L1 write packet:** Contains an L1 address and a variable amount of data. Upon receiving this kind of packet, the RX queue will write the data to the specified address in L1.
* **NoC Overlay packet:** Similar to an L1 write packet, but also has some additional metadata required to support NoC Overlay streams.

> [!WARNING] 
> The three RX queues in each Ethernet tile are not quite identical, as RX queue #2 does not support receiving TT-link MMIO write packets. At any given time, at most one RX queue can be configured to receive TT-link MMIO write packets, and at most one RX queue can be configured to receive TT-link NoC Overlay packets.

## TX Queues

Each Ethernet tile has three Ethernet TX queues. Each TX queue supports two modes:
* Raw TX mode
* TT-link TX mode

In raw TX mode, software can pass arbitrary Ethernet payloads to the TX queue, which will prepend an entry from the TX header table and then send the result out over the wire. The TX queue will transmit raw packets in the order they were enqueued, but once on the wire, the packets might be dropped or reordered (or in extreme cases, duplicated). Note that if direct attach cables are used between two Tenstorrent devices, with no Ethernet switches or routers between them, then drops can still happen, but reordering / duplication should not.

In TT-link TX mode, the TX queue transmits TT-link packets. These packets have a header which includes TT-link sequence numbers, and the TX queue will repeatedly re-send packets until it receives acknowledgement of their receipt (meanwhile, the recipient will discard packets with duplicate sequence numbers). This requires that the TX queue keep a copy of the packet metadata for all unacknowledged packets, and requires that it re-fetch the packet body from L1 for every re-send attempt. Software can instruct the TX queue to send MMIO write packets or L1 write packets, whereas sequence number update packets are generated internally when there are no other packets for them to piggy-back on, and NoC Overlay packets are generated by the [NoC Overlay](../NoC/Overlay/README.md).

> [!WARNING] 
> The three TX queues in each Ethernet tile are not quite identical, as TX queue #2 does not support transmitting TT-link MMIO write packets nor TT-link NoC Overlay packets. At any given time, at most one TX queue can be configured to transmit TT-link NoC Overlay packets.

## Associating TX queues with RX queues

When operating in TT-link mode, it is expected that local TX queue #0 is communicating with some remote RX queue #0, and that local TX queue #1 is communicating with some remote RX queue #1. Firmware will configure things as necessary to ensure this: it will ensure an appropriate destination MAC address is used for outbound TT-link packets, and it will configure the RX classifier to route incoming packets to RX queues based on destination MAC address.

When operating in raw mode, TX queues and RX queues are totally separate entities; no association is necessary.

## TX Header Table

All three TX queues share a single TX header table, which has 10 entries. Software can choose which table entry is used for different types of outgoing packets. Each table entry always contains:
* Destination MAC address
* Source MAC address
* An ethertype, or an indication that outgoing packets should have a length rather than an ethertype

Each table entry can _optionally_ also contain:
* Up to two VLAN tags
* An L3 header, such as IPv4 or IPv6
* An L4 header, such as TCP or UDP (though this has limited value for TCP, as hardware does not track TCP sequence numbers, nor manage a TCP state machine)

In raw TX mode, software can use the optional parts of a header table entry if it wishes, but does not _need_ to; it can instead supply these headers on a packet-by-packet basis. In TT-link TX mode, software must use the optional parts of a header table entry if it wants the relevant headers to be present. In either case, if inserting headers, hardware can optionally overwrite the length and checksum fields in the headers.

## TX Queue Memory Map

TX queue #0 has `TXQ_BASE` of `0xFFB9_0000`, TX queue #1 has `TXQ_BASE` of `0xFFB9_1000`, and TX queue #2 has `TXQ_BASE` of `0xFFB9_2000`.

|Address|Name|Purpose|
|---|---|---|
|`TXQ_BASE + 0x00`|[`ETH_TXQ_CTRL`](#eth_txq_ctrl)|Miscellaneous configuration bits|
|`TXQ_BASE + 0x04`|[`ETH_TXQ_CMD`](#eth_txq_cmd)|Write to request that a packet be transmitted|
|`TXQ_BASE + 0x08`|[`ETH_TXQ_STATUS`](#eth_txq_status)|Read to confirm that a previous request has been enqueued and thus the TX queue is ready for the next request|
|`TXQ_BASE + 0x0C`|`ETH_TXQ_MAX_PKT_SIZE_BYTES`|Maximum packet size (in bytes). When `ETH_TXQ_TRANSFER_SIZE_BYTES` exceeds this value, the TX queue will automatically split outgoing packets|
|`TXQ_BASE + 0x14`|`ETH_TXQ_TRANSFER_START_ADDR`|**TT-link L1 write packets:** The L1 address in the local tile to read from (must be 16-byte aligned)<br/>**TT-link MMIO write packets:** Ignored (data instead comes from `ETH_TXQ_REMOTE_REG_DATA`)<br/>**Raw packets:** The L1 address in the local tile to read from|
|`TXQ_BASE + 0x18`|`ETH_TXQ_TRANSFER_SIZE_BYTES`|**TT-link L1 write packets:** The number of bytes to read from the local L1 and write to the remote L1 (must be a multiple of 16)<br/>**TT-link MMIO write packets:** Ignored (length is always 4 bytes)<br/>**Raw packets:** The number of bytes to read from the local L1 to form the main packet contents (this is not the final packet length, as the TX header table will add additional bytes)|
|`TXQ_BASE + 0x1C`|`ETH_TXQ_DEST_ADDR`|**TT-link L1 write packets:** The remote L1 address to write to (must be 16-byte aligned)<br/>**TT-link MMIO write packets:** The remote MMIO address to write to (must be 4-byte aligned)<br/>**Raw packets:** Ignored (the receiving RX queue controls the address)|
|`TXQ_BASE + 0x30`|`ETH_TXQ_TRANSFER_CNT`|Counter which hardware increments by one every time hardware actually enqueues a request made via `ETH_TXQ_CMD`|
|`TXQ_BASE + 0x34`|`ETH_TXQ_PKT_START_CNT`|Counter which hardware increments by one every time it starts sending a packet|
|`TXQ_BASE + 0x3C`|`ETH_TXQ_PKT_END_CNT`|Counter which hardware increments by one every time it finishes sending a packet|
|`TXQ_BASE + 0x40`|`ETH_TXQ_WORD_CNT`|Counter which hardware increments by one for every 96 bytes (or part thereof) transmitted|
|`TXQ_BASE + 0x44`|`ETH_TXQ_REMOTE_REG_DATA`|**TT-link L1 write packets:** Ignored<br/>**TT-link MMIO write packets:** The 32 bits of data to write<br/>**Raw packets:** Ignored|
|`TXQ_BASE + 0x48`|`ETH_TXQ_REMOTE_SEQ_TIMEOUT`|After a TT-link packet has been transmitted, if it remains unacknowledged for this many cycles, it'll be re-sent|
|<code>TXQ_BASE&nbsp;+&nbsp;0x4C</code>|`ETH_TXQ_LOCAL_SEQ_UPDATE_TIMEOUT`|When `ETH_TXQ_CTRL` indicates that TT-link sequence number update packets should be sent, the frequency (in cycles) at which they should be sent|
|`TXQ_BASE + 0x80`|[`ETH_TXQ_TXPKT_CFG_SEL_SW`](#eth_txq_txpkt_cfg_sel_sw)|**TT-link L1 write packets:** 4 bits herein specify which TX header table entry to use<br/>**TT-link MMIO write packets:** 4 bits herein specify which TX header table entry to use<br/>**Raw packets:** 4 bits herein specify which TX header table entry to use|
|`TXQ_BASE + 0x84`|[`ETH_TXQ_TXPKT_CFG_SEL_HW`](#eth_txq_txpkt_cfg_sel_hw)|**TT-link sequence number update packets:** 4 bits herein specify which TX header table entry to use|
|`TXQ_BASE + 0x88`|[`ETH_TXQ_TXPKT_CFG_SEL_OVL`](#eth_txq_txpkt_cfg_sel_ovl)|**TT-link NoC Overlay packets:** 4 bits herein specify which TX header table entry each NoC Overlay stream should use|

### `ETH_TXQ_CTRL`

|First&nbsp;bit|#&nbsp;Bits|Name|Purpose|
|--:|--:|---|---|
|0|1|`ETH_TXQ_CTRL_KEEPALIVE`|If `true`, a TT-link sequence number update packet will be transmitted every `ETH_TXQ_LOCAL_SEQ_UPDATE_TIMEOUT` cycles (unless some other TT-link packet was sent in that period). If `false`, TT-link sequence number update packets will not be transmitted. This effectively serves as the configuration bit controlling whether the TX queue is operating in raw TX mode or TT-link TX mode, as regular TT-link packets are strongly advised in TT-link TX mode, and strongly discouraged in raw TX mode.|
|1|2|Reserved|Should be zero|
|3|1|`ETH_TXQ_CTRL_DIS_DROP`|When TT-link is in use, configures the resend strategy. No effect if TT-link is not in use. If set to `true`, packets will only be resent due to timeout. If set to `false`, packets will be resent due to timeout _or_ due to explicit drop notifications.|
|4|28|Reserved|Can take any value|

### `ETH_TXQ_CMD`

Write a value of `1` to request that the TX queue transmit a raw packet. The source L1 address and length should have been set in `ETH_TXQ_TRANSFER_START_ADDR` and `ETH_TXQ_TRANSFER_SIZE_BYTES` respectively, and an appropriate TX header table index set in the low four bits of `ETH_TXQ_TXPKT_CFG_SEL_SW`. Following the write to `ETH_TXQ_CMD`, software should hold the values of all these fields constant. Hardware will set `ETH_TXQ_STATUS_CMD_ONGOING_BIT` within `ETH_TXQ_STATUS` as software writes to `ETH_TXQ_CMD`, and then clear it once it has finished reading the packet data from L1, after which software is free to change `ETH_TXQ_TRANSFER_START_ADDR` and `ETH_TXQ_TRANSFER_SIZE_BYTES` and `ETH_TXQ_TXPKT_CFG_SEL_SW`.

Write a value of `2` to request that the TX queue transmit a TT-link L1 write packet. The properties of the packet should have been set in `ETH_TXQ_TRANSFER_START_ADDR`, `ETH_TXQ_TRANSFER_SIZE_BYTES`, and `ETH_TXQ_DEST_ADDR`, and an appropriate TX header table index set in bits 8 through 11 of `ETH_TXQ_TXPKT_CFG_SEL_SW`. Hardware will set `ETH_TXQ_STATUS_CMD_ONGOING_BIT` within `ETH_TXQ_STATUS` as software writes to `ETH_TXQ_CMD`, and then clear it once it has latched the packet metadata, after which software is free to change the fields again. Note that hardware does not provide an indication of when it has finished reading from L1, and it may need to read the packet data out of L1 several times if re-sends are required.

Write a value of `4` to request that the TX queue transmit a TT-link MMIO write packet (TX queues #0 and #1 only). The properties of the packet should have been set in `ETH_TXQ_DEST_ADDR` and `ETH_TXQ_REMOTE_REG_DATA`, and an appropriate TX header table index set in bits 4 through 7 of `ETH_TXQ_TXPKT_CFG_SEL_SW`. Hardware will set `ETH_TXQ_STATUS_CMD_ONGOING_BIT` within `ETH_TXQ_STATUS` as software writes to `ETH_TXQ_CMD`, and then clear it once it has latched the packet metadata, after which software is free to change the fields again.

After writing to `ETH_TXQ_CMD`, software must not write to `ETH_TXQ_CMD` again until the command has been accepted and enqueued. It can determine when this has happened by reading from `ETH_TXQ_STATUS` and looking at the `ETH_TXQ_STATUS_CMD_ONGOING_BIT` bit therein. If software writes to `ETH_TXQ_CMD` and then _immediately_ reads from `ETH_TXQ_STATUS`, [RISCV memory ordering](../TensixTile/BabyRISCV/MemoryOrdering.md) rules should be consulted to ensure that the read and the write are not reordered. To ensure correct ordering in this particular scenario, it suffices to read back from `ETH_TXQ_CMD` before reading from `ETH_TXQ_STATUS`.

> [!TIP]
> Wormhole allowed software to read from `ETH_TXQ_CMD` and obtain a meaningful value. Blackhole always returns zero for such reads; software is directed to `ETH_TXQ_STATUS` instead.

### `ETH_TXQ_STATUS`

|First&nbsp;bit|#&nbsp;Bits|Name|Purpose|
|--:|--:|---|---|
|0|16|Reserved|Various undocumented debug status codes|
|16|1|`ETH_TXQ_STATUS_CMD_ONGOING_BIT`|When software writes to `ETH_TXQ_CMD`, hardware will set `ETH_TXQ_STATUS_CMD_ONGOING_BIT` to `true`. Hardware will transition it back to `false` once software is allowed to write to `ETH_TXQ_CMD` again.|
|17|15|Reserved|Always zero|

### `ETH_TXQ_TXPKT_CFG_SEL_SW`

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|4|TX header table index to use when transmitting raw packets|
|4|4|TX header table index to use when transmitting TT-link MMIO write packets|
|8|4|TX header table index to use when transmitting TT-link L1 write packets|
|12|12|Reserved|

### `ETH_TXQ_TXPKT_CFG_SEL_HW`

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|4|TX header table index to use when transmitting TT-link sequence number update packets|
|4|28|Reserved|

### `ETH_TXQ_TXPKT_CFG_SEL_OVL`

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #0|
|4|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #1|
|8|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #2|
|12|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #3|
|16|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #4|
|20|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #5|
|24|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #6|
|28|4|TX header table index to use when transmitting TT-link NoC Overlay packets for stream #7|

## TX Header Table Memory Map

Table entry `i` (for `0 â‰¤ i < 10`) has `TXPKT_CFG_BASE` of `0xFFB9_8200 + i * 0x80`.

|Address|Name|Size (bytes)|Purpose|
|---|---|--:|---|
|`TXPKT_CFG_BASE + 0x00`|[`INSERT_CTL`](#insert_ctl)|4|Miscellaneous configuration bits|
|`TXPKT_CFG_BASE + 0x04`|`CUSTOM_HDR_L3`|2|If inserting a custom L3 header, the length of that header, in bytes (must be an even value between `0` and `40`)|
|`TXPKT_CFG_BASE + 0x06`|`CUSTOM_HDR_L4`|2|If inserting a custom L4 header, the length of that header, in bytes (must be an even value between `0` and `20`)|
|`TXPKT_CFG_BASE + 0x10`|`MAC_SA`|6|The source MAC address to use (in reverse byte order)|
|`TXPKT_CFG_BASE + 0x18`|`MAC_DA`|6|The destination MAC address to use (in reverse byte order)|
|`TXPKT_CFG_BASE + 0x20`|`USE_ETHERTYPE`|1|If `true`, transmitted packets include the ethertype specified in `ETHERTYPE`. If `false`, transmitted packets instead include their length|
|`TXPKT_CFG_BASE + 0x22`|`ETHERTYPE`|2|Ethertype for transmitted packets, when `USE_ETHERTYPE` indicates an ethertype should be included (otherwise a length is included)|
|`TXPKT_CFG_BASE + 0x24`|`VLAN1`|4|If inserting VLAN tags, the 1<sup>st</sup> VLAN tag to insert (this is 32 bits, i.e. the complete 802.1Q header or 802.1ad header, rather than just the 12 bits of VLAN ID)|
|`TXPKT_CFG_BASE + 0x28`|`VLAN2`|4|If inserting two VLAN tags, the 2<sup>nd</sup> VLAN tag to insert (this is 32 bits, i.e. the complete 802.1Q header, rather than just the 12 bits of VLAN ID)|
|`TXPKT_CFG_BASE + 0x30`|`L3_HEADER`|40|If inserting an L3 header, the contents of that header (each group of four bytes is in network byte order)|
|<code>TXPKT_CFG_BASE&nbsp;+&nbsp;0x60</code>|`L4_HEADER`|20|If inserting an L4 header, the contents of that header (each group of four bytes is in network byte order)|

> [!CAUTION] 
> MMIO writes, including those to fields within `TXPKT_CFG_BASE`, must always have a length of four bytes, and be four byte aligned. This sometimes means that software has no choice but to write multiple adjacent fields of `TXPKT_CFG_BASE` simultaneously. The MAC address fields are both followed by two bytes of padding, which software can write anything to. There is a similar padding byte between `USE_ETHERTYPE` and `ETHERTYPE`.

### `INSERT_CTL`

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|1|If `true`, `VLAN1` is inserted|
|1|3|Reserved|
|4|1|If `true`, and bit #0 is also `true`, both of `VLAN1` and `VLAN2` are inserted|
|5|3|Reserved|
|8|1|If `true`, an L3 header is inserted|
|9|3|Reserved|
|12|2|If bit #8 is `true`, the type of L3 header to insert:<ul><li><code>0</code>: IPv4 header (20 bytes, from first 20 bytes of <code>L3_HEADER</code>, with hardware overwriting the length and checksum fields)</li><li><code>1</code>: IPv6 header (40 bytes, from <code>L3_HEADER</code>, with hardware overwriting the length field)</li><li><code>2</code>: Reserved</li><li><code>3</code>: Custom header (up to 40 bytes from start of <code>L3_HEADER</code>, length in <code>CUSTOM_HDR_L3</code>)</li></ul>|
|14|2|Reserved|
|16|1|If `true`, an L4 header is inserted|
|17|1|Reserved|
|18|1|If `true`, and other fields indicate that an L4 TCP or UDP header should be inserted, then hardware will correctly populate the checksum within that header|
|19|1|Reserved|
|20|2|If bit #16 is `true`, the type of L4 header to insert:<ul><li><code>0</code>: UDP header (8 bytes, from first 8 bytes of <code>L4_HEADER</code>, with hardware overwriting the length field and optionally also the checksum field)</li><li><code>1</code>: TCP header (20 bytes, from <code>L4_HEADER</code>, with hardware overwriting the length field and optionally also the checksum field)</li><li><code>2</code>: Reserved</li><li><code>3</code>: Custom header (up to 20 bytes from start of <code>L4_HEADER</code>, length in <code>CUSTOM_HDR_L4</code>)</li></ul>|
|22|4|Reserved|
|26|1|If `true`, and other fields indicate that an L3 header should be inserted, an RoCE iCRC will be inserted|
|27|5|Reserved|

The final transmitted Ethernet frame on the wire will be the concatenation of:
1. `MAC_DA`
2. `MAC_SA`
3. If `INSERT_CTL` specifies to insert VLAN tags, `VLAN1`
4. If `INSERT_CTL` specifies to insert two VLAN tags, `VLAN2`
5. Either `ETHERTYPE` or length, depending on the value of `USE_ETHERTYPE`
6. If `INSERT_CTL` specifies to insert an L3 header, bytes from `L3_HEADER` (possibly with length and checksum overwritten)
7. If `INSERT_CTL` specifies to insert an L4 header, bytes from `L4_HEADER`  (possibly with length and checksum overwritten)
8. If transmitting a TT-link packet, the TT-link header
9. If transmitting a raw packet, or a TT-link L1 write packet, the bytes referenced by `ETH_TXQ_TRANSFER_START_ADDR` and `ETH_TXQ_TRANSFER_SIZE_BYTES` (other types of TT-link packet also have their variable payload here)
10. If `INSERT_CTL` specifies to insert an RoCE iCRC, the RoCE iCRC
11. The Ethernet CRC

The receiver does not care exactly how the concatenation is formed, so raw packet transmitters are free to supply headers as part of step 9 rather than using steps 3/4/6/7/10.

## RX Classifier Memory Map

Due to its complexity, [the RX classifier is described separately](EthernetRxClassifier.md).

## RX Queue Memory Map

RX queue #0 has `RXQ_BASE` of `0xFFB9_4000`, RX queue #1 has `RXQ_BASE` of `0xFFB9_5000`, and RX queue #2 has `RXQ_BASE` of `0xFFB9_6000`.

|Address|Name|Purpose|
|---|---|---|
|<code>RXQ_BASE&nbsp;+&nbsp;0x00</code>|[`ETH_RXQ_CTRL`](#eth_rxq_ctrl)|Miscellaneous configuration bits|
|`RXQ_BASE + 0x04`|`ETH_RXQ_BYTE_CNT`|Counter which hardware increments by the number of bytes that this RX queue has written to L1 (the counter is incremented before the writes are complete; software can use `ETH_RXQ_OUTSTANDING_WR_CNT` to track the potentially uncompleted amount)|
|`RXQ_BASE + 0x08`|`ETH_RXQ_BUF_PTR`|**Raw RX mode:** The offset (in bytes) within the RX buffer where the next incoming frame will be written. Software can safely read up to `ETH_RXQ_BUF_PTR - ETH_RXQ_OUTSTANDING_WR_CNT * 96`; the gap between the two represents data which has been received from the network but not yet committed to L1|
|`RXQ_BASE + 0x0C`|`ETH_RXQ_BUF_START_WORD_ADDR`|**Raw RX mode:** The RX buffer starts at address `ETH_RXQ_BUF_START_WORD_ADDR << 4` in L1|
|`RXQ_BASE + 0x10`|`ETH_RXQ_BUF_SIZE_WORDS`|**Raw RX mode:** The size of the RX buffer is `ETH_RXQ_BUF_SIZE_WORDS << 4` bytes|
|`RXQ_BASE + 0x14`|`ETH_RXQ_WORD_CNT`|Counter which hardware increments by one for every 96 bytes (or part thereof) received. This includes both packet headers and bodies. The counter is incremented after the data has been received from the network, but before it has been committed to L1|
|`RXQ_BASE + 0x18`|`ETH_RXQ_HDR_CTRL`|**Raw RX mode:** The number of bytes to strip from the start of incoming frames. The default value of 14 is designed to strip off Ethernet MAC addresses and ethertype. If the RX classifier is configured to _insert_ metadata at the start of the frame, this field should be set to zero, otherwise the metadata will be the first thing to be stripped off|
|`RXQ_BASE + 0x24`|`ETH_RXQ_PKT_START_CNT`|Counter which hardware increments by one for every received packet. The counter is incremented as the start of the ethernet frame is observed|
|`RXQ_BASE + 0x28`|`ETH_RXQ_PKT_END_CNT`|Counter which hardware increments by one for every received packet. The counter is incremented after the end of the ethernet frame has been observed, but possibly before the entire packet body has been committed to L1|
|`RXQ_BASE + 0x40`|`ETH_RXQ_LOCAL_RX_SEQ_NUM`|**TT-link RX mode:** The next sequence number we expect to receive|
|`RXQ_BASE + 0x44`|`ETH_RXQ_REMOTE_RX_SEQ_NUM`|**TT-link RX mode:** The sequence acknowledgement number contained within the most recently received TT-link packet (the TX queue uses this to confirm receipt of transmitted TT-link packets; the value is available here mainly for debugging purposes)|
|`RXQ_BASE + 0x48`|[`ETH_RXQ_TILE_HEADER_FORMAT`](#eth_rxq_tile_header_format)|**TT-link RX mode:** Additional configuration for NoC Overlay packets|
|`RXQ_BASE + 0x4C`|`ETH_RXQ_PACKET_DROP_CNT`|Read-only. Counter which hardware increments by one for every packet which is received by the RX queue but then discarded (e.g. due to sequence number mismatch in TT-link RX mode, or due to RX buffer full in raw RX mode). This does not include anything which was dropped by the RX classifier _before_ reaching an RX queue|
|`RXQ_BASE + 0x50`|`ETH_RXQ_OUTSTANDING_WR_CNT`|Read-only. `ETH_RXQ_OUTSTANDING_WR_CNT * 96` is (an upper bound on) the number of bytes which have been received from the network but not yet committed to L1|

### `ETH_RXQ_CTRL`

|First&nbsp;bit|#&nbsp;Bits|Name|Purpose|
|--:|--:|---|---|
|0|1|Reserved|Writes ignored, reads as zero|
|1|1|`ETH_RXQ_CTRL_PACKET_MODE`|If `true`, all received packets are assumed to be TT-link packets (i.e. RX queue operating in TT-link RX mode). If `false`, all received packets will be appended to the RX buffer (i.e. RX queue operating in raw RX mode).|
|2|1|`ETH_RXQ_CTRL_BUF_WRAP`|**Raw RX mode:** If `true`, hardware will automatically reset `ETH_RXQ_BUF_PTR` to zero when it hits `ETH_RXQ_BUF_SIZE_WORDS << 4`. If `false`, hardware will instead drop incoming data once `ETH_RXQ_BUF_PTR == ETH_RXQ_BUF_SIZE_WORDS << 4`. In either case, when `ETH_RXQ_BUF_PTR` is approaching `ETH_RXQ_BUF_SIZE_WORDS << 4`, incoming data will be split in two: just enough will be written to cause `ETH_RXQ_BUF_PTR` to equal `ETH_RXQ_BUF_SIZE_WORDS << 4`, and then either:<ul><li>`ETH_RXQ_CTRL_BUF_WRAP` is `true`: remainder written to the start of the buffer, and `ETH_RXQ_BUF_PTR` set to the number of bytes written there (software will never see the intermediate state where `ETH_RXQ_BUF_PTR` equals `ETH_RXQ_BUF_SIZE_WORDS << 4`)</li><li>`ETH_RXQ_CTRL_BUF_WRAP` is `false`: remainder dropped, and `ETH_RXQ_BUF_PTR` stays equal to `ETH_RXQ_BUF_SIZE_WORDS << 4`</li></ul>|
|3|29|Reserved|Writes ignored, reads as zero|

### `ETH_RXQ_TILE_HEADER_FORMAT`

This serves the same purpose as [`STREAM_MSG_HEADER_FORMAT_REG_INDEX`](../NoC/Overlay/README.md#stream_msg_header_format_reg_index), just for TT-link NoC Overlay packets received over Ethernet, rather than NoC Overlay packets received over the NoC.

|First&nbsp;bit|#&nbsp;Bits|Purpose|
|--:|--:|---|
|0|7|Byte offset of least significant bit of message length field within message header. Note that this is a byte offset, whereas in `STREAM_MSG_HEADER_FORMAT_REG_INDEX`, the corresponding field is a bit offset|
|7|7|Bit width of message length field within message header|
|14|18|Reserved|Writes ignored, reads as zero|
